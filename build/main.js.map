{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/**\n * -------------------------------------------------------------------\n * ioBroker Roborock Adapter\n * @github  https://github.com/Acgua/ioBroker.roborock\n * @author  Acgua <https://github.com/Acgua/ioBroker.roborock>\n * @created Adapter Creator v2.1.1\n * @license Apache License 2.0\n * -------------------------------------------------------------------\n * Many thanks to rovo89 (https://github.com/rovo89) for his awesome work on the development of\n * a full-working proof of concept and decryption of the Roborock API!\n *  - https://forum.iobroker.net/topic/56098/tester-gesucht-roborock-api\n *  - https://gist.github.com/rovo89/dff47ed19fca0dfdda77503e66c2b7c7\n * -------------------------------------------------------------------\n */\n\nimport * as utils from '@iobroker/adapter-core';\nimport EventEmitter from 'node:events';\n\n/**\n * Developer setup:\n * For all following NPM modules: open console, change dir e.g. to \"C:\\iobroker\\node_modules\\ioBroker.roborock\\\",\n * and execute \"npm install <module name>\", ex: npm install axios.\n */\nimport axios from 'axios';\nimport { Parser } from 'binary-parser';\nimport CRC32 from 'crc-32';\nimport mqtt from 'mqtt';\nimport crypto from 'node:crypto';\nimport zlib from 'zlib';\n\n// import methods lib\nimport { err2Str, isEmpty, wait } from './lib/methods';\n\n// Constants\n// This value is stored hardcoded in librrcodec.so, encrypted by the value of \"com.roborock.iotsdk.appsecret\" from AndroidManifest.xml.\nconst salt = 'TXdfu$jyZ#TZHsg4';\n\n/**\n * Main Adapter Class\n * Note: \"export\" keyword used due to access to class instance in lib/methods\n */\nexport class Roborock extends utils.Adapter {\n    // Imported methods from ./lib/methods\n    public err2Str = err2Str.bind(this);\n    public wait = wait.bind(this);\n    public isEmpty = isEmpty.bind(this);\n    // Other\n    public userdata = {} as { [k: string]: any };\n    public homedata = {} as { [k: string]: any };\n\n    /**\n     * Constructor\n     */\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({ ...options, name: 'roborock' });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    /**\n     * Called once ioBroker databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        try {\n            // Reset the connection indicator during startup\n            this.setState('info.connection', { val: false, ack: true });\n\n            /**\n             * User settings verification\n             */\n            // Basic verification of user name and pw\n            if (!this.config.username || this.config.username.trim().length < 1) throw `Not valid username '${this.config.username}' set in adapter configuration!`;\n            if (!this.config.password || this.config.password.trim().length < 2) throw `Not valid password '${this.config.password}' set in adapter configuration`;\n\n            // Create objects\n            // TODO: We will actually not need these states, this is just temporarily...\n            await this.setObjectNotExistsAsync('userdata', { type: 'state', common: { name: 'Roborock userdata', type: 'string', role: 'json', read: true, write: false, def: '' }, native: {} });\n            await this.setObjectNotExistsAsync('homedata', { type: 'state', common: { name: 'Roborock homedata', type: 'string', role: 'json', read: true, write: false, def: '' }, native: {} });\n\n            // Get userdata and homedata\n            await this.getRoborockUserHomedata();\n\n            // Create objects\n            for (const prod of this.homedata.products) {\n                this.log.debug(`Creating objects for ${prod.name} - id: ${prod.id} ...`);\n                await this.setObjectNotExistsAsync(prod.id, { type: 'device', common: { name: prod.name }, native: {} });\n                await this.setObjectNotExistsAsync(`${prod.id}.info`, { type: 'channel', common: { name: 'Information' }, native: {} });\n                // Erst mal alle als String\n                // TODO: Verbessern\n                for (const itm of prod.schema) {\n                    this.log.debug(`Create state for ${prod.id}.info.${itm.code} ...`);\n                    await this.setObjectNotExistsAsync(`${prod.id}.info.${itm.code}`, { type: 'state', common: { name: `${itm.code}`, type: 'string', role: 'info', read: true, write: false, def: '' }, native: {} });\n                }\n            }\n\n            // TODO: This just as a test, to wait certain seconds\n            this.log.info(`- wait 2 seconds ----------------------------------------`);\n            await this.wait(2000);\n\n            await this.main();\n        } catch (e) {\n            this.log.error(this.err2Str(e));\n        }\n    }\n\n    private async main(): Promise<void> {\n        try {\n            const rriot = this.userdata.rriot;\n            const devices = this.homedata.devices.concat(this.homedata.receivedDevices);\n            const localKeys = new Map(devices.map((device: { [k: string]: any }) => [device.duid, device.localKey]));\n\n            let seq = 1;\n            let random = 4711; // Should be initialized with a number 0 - 1999?\n            let idCounter = 1;\n\n            const endpoint = this.md5bin(rriot.k).subarray(8, 14).toString('base64'); // Could be a random but rather static string. The app generates it on first run.\n            const nonce = crypto.randomBytes(16);\n\n            const mqttMessageParser = new Parser().endianess('big').string('version', { length: 3 }).uint32('seq').uint32('random').uint32('timestamp').uint16('protocol').uint16('payloadLen').buffer('payload', { length: 'payloadLen' }).uint32('crc32');\n\n            const protocol301Parser = new Parser().endianess('little').string('endpoint', { length: 15, stripNull: true }).uint8('unknown1').uint16('id').buffer('unknown2', { length: 6 });\n\n            const mqttUser = this.md5hex(rriot.u + ':' + rriot.k).substring(2, 10);\n            const mqttPassword = this.md5hex(rriot.s + ':' + rriot.k).substring(16);\n\n            /**\n             * Connect MQTT\n             */\n            const rr = new EventEmitter();\n            let client: mqtt.Client;\n            try {\n                client = mqtt.connect(rriot.r.m, { username: mqttUser, password: mqttPassword, keepalive: 30 });\n                client.on('connect', () => {\n                    // MQTT subscribe\n                    client.subscribe(`rr/m/o/${rriot.u}/${mqttUser}/#`, (err, granted) => {\n                        // handle err\n                        if (err) throw `${this.homedata.name}: Connection error occcurred while trying to establish MQTT connection`;\n\n                        this.log.debug(`${this.homedata.name} -- Granted variable: ${JSON.stringify(granted)}`);\n                        // TODO: we will need to cover all devices, and not just the first one.\n                        const deviceId = devices[0].duid; // Simply use the first device.\n                        sendRequest(this, deviceId, 'get_prop', ['get_status']).then((result) => {\n                            this.log.info(`${this.homedata.name}: First device get_prop RESULT: ${JSON.stringify(result)}`);\n                        });\n                        sendRequest(this, deviceId, 'get_map_v1', [], true).then((result) => {\n                            //this.log.info(`${this.homedata.name}: First device get_map_v1 RESULT: ${result}`);\n                        });\n                    });\n                });\n\n                /**\n                 * MQTT: on message\n                 */\n                client.on('message', (topic: string, message) => {\n                    try {\n                        // topic looks like: 'rr/m/o/xxxxxx/yyyyyyy/zzzzzz' (x,y,z replaced)\n                        const deviceId = topic.split('/').slice(-1)[0]; // last part of topic string, e.g. zzzzzz\n                        const lclKey = localKeys.get(deviceId); // '8ZTRX55abz9ZS1ua'\n                        if (!lclKey || typeof lclKey !== 'string') throw `localKeys.get(deviceId) failed: not existing or not a string`;\n                        const data = _decodeMsg(this, message, lclKey);\n                        if (!data) throw `message could not be decoded!`;\n                        rr.emit('response.raw', deviceId, data);\n                        if (!data.payload || this.isEmpty(data.payload)) throw `no data.payload available!`;\n                        switch (data.protocol) {\n                            case 102:\n                                this.log.debug(`--------- reached data protocol 102`);\n                                const pl = JSON.parse(data.payload);\n                                if (!pl.dps || !pl.dps['102']) throw `data.payload.dps / data.payload.dps['102] is not available!`;\n                                const dps = JSON.parse(pl.dps['102']);\n                                if (!dps || !dps.result) {\n                                    this.log.error(`dps / dps.result is not available!`);\n                                    throw `data.payload: ${JSON.stringify(data.payload)}`;\n                                }\n\n                                rr.emit('response.102', deviceId, dps.id, dps.result[0]);\n                                break;\n                            case 301:\n                                this.log.debug(`--------- reached data protocol 301`);\n                                const data2 = protocol301Parser.parse(data.payload.subarray(0, 24));\n                                if (endpoint.startsWith(data2.endpoint)) {\n                                    const iv = Buffer.alloc(16, 0);\n                                    const decipher = crypto.createDecipheriv('aes-128-cbc', nonce, iv);\n                                    let decrypted = Buffer.concat([decipher.update(data.payload.subarray(24)), decipher.final()]);\n                                    decrypted = zlib.gunzipSync(decrypted);\n                                    rr.emit('response.301', deviceId, data2.id, decrypted);\n                                }\n                                break;\n                            default:\n                                this.log.warn(`Not (yet) covered data.protocol: ${data.protocol}`);\n                        }\n                    } catch (e) {\n                        this.log.error(`MQTT on message error: ${this.err2Str(e)}`);\n                    }\n                });\n            } catch (e) {\n                this.log.error(`MAIN: MQTT connect error: ${this.err2Str(e)}`);\n            }\n\n            /**\n             * MQTT: send request\n             * @param adapter  - \"this\"\n             * @param deviceId - device id\n             * @param method   - method\n             * @param params   - parameter\n             * @param secure   - if secure\n             * @returns some result\n             */\n            async function sendRequest(adapter: Roborock, deviceId: string, method: string, params: any, secure = false): Promise<any> {\n                const timestamp = Math.floor(Date.now() / 1000);\n                const requestId = idCounter++;\n                const inner = { id: requestId, method: method, params: params } as { [key: string]: any };\n                if (secure) {\n                    inner.security = { endpoint: endpoint, nonce: nonce.toString('hex').toUpperCase() };\n                }\n                const payload = JSON.stringify({ t: timestamp, dps: { '101': JSON.stringify(inner) } });\n                return new Promise((resolve, reject) => {\n                    rr.on('response.102', (deviceId, id, result) => {\n                        if (id == requestId) {\n                            if (secure) {\n                                if (result !== 'ok') {\n                                    reject(result);\n                                }\n                            } else {\n                                resolve(result);\n                            }\n                        }\n                    });\n                    if (secure) {\n                        rr.on('response.301', (deviceId, id, result) => {\n                            if (id == requestId) {\n                                resolve(result);\n                            }\n                        });\n                    }\n                    sendMsgRaw(adapter, deviceId, 101, timestamp, payload);\n                });\n            }\n\n            /**\n             * MQTT: send raw message\n             * @param adapter   - \"this\"\n             * @param deviceId  - device id\n             * @param protocol  - protocol number\n             * @param timestamp - timestamp\n             * @param payload   - payload str\n             */\n            function sendMsgRaw(adapter: Roborock, deviceId: string, protocol: number, timestamp: number, payload: string): void {\n                const localKey = localKeys.get(deviceId);\n                const aesKey = adapter.md5bin(_encodeTimestamp(timestamp) + localKey + salt);\n                const cipher = crypto.createCipheriv('aes-128-ecb', aesKey, null);\n                const encrypted = Buffer.concat([cipher.update(payload), cipher.final()]);\n                const msg = Buffer.alloc(23 + encrypted.length);\n                msg.write('1.0');\n                msg.writeUint32BE(seq++ & 0xffffffff, 3);\n                msg.writeUint32BE(random++ & 0xffffffff, 7);\n                msg.writeUint32BE(timestamp, 11);\n                msg.writeUint16BE(protocol, 15);\n                msg.writeUint16BE(encrypted.length, 17);\n                encrypted.copy(msg, 19);\n                const crc32 = CRC32.buf(msg.subarray(0, msg.length - 4)) >>> 0;\n                msg.writeUint32BE(crc32, msg.length - 4);\n                client.publish(`rr/m/i/${rriot.u}/${mqttUser}/${deviceId}`, msg);\n            }\n\n            /**\n             * Encode timestamp\n             * @param timestamp\n             * @returns encoded timestamp\n             */\n            function _encodeTimestamp(timestamp: number): string {\n                const hex = timestamp.toString(16).padStart(8, '0').split('');\n                return [5, 6, 3, 7, 1, 2, 0, 4].map((idx) => hex[idx]).join('');\n            }\n            /**\n             * Decode message\n             * @param adapter - \"this\"\n             * @param msg\n             * @param localKey\n             * @returns decoded message\n             */\n            function _decodeMsg(adapter: Roborock, msg: any, localKey: string): { [k: string]: any } | undefined {\n                try {\n                    // Do some checks before trying to decode the message.\n                    if (msg.toString('latin1', 0, 3) !== '1.0') throw `Unknown protocol version`;\n\n                    const crc32 = CRC32.buf(msg.subarray(0, msg.length - 4)) >>> 0;\n                    const expectedCrc32 = msg.readUint32BE(msg.length - 4);\n                    if (crc32 != expectedCrc32) throw `Wrong CRC32 ${crc32}, expected ${expectedCrc32}`;\n\n                    const data = mqttMessageParser.parse(msg);\n                    delete data.payloadLen;\n                    const aesKey = adapter.md5bin(_encodeTimestamp(data.timestamp) + localKey + salt);\n                    const decipher = crypto.createDecipheriv('aes-128-ecb', aesKey, null);\n                    data.payload = Buffer.concat([decipher.update(data.payload), decipher.final()]);\n                    return data;\n                } catch (e) {\n                    adapter.log.error(`_decodeMsg(): ${adapter.err2Str(e)}`);\n                    return undefined;\n                }\n            }\n        } catch (e) {\n            this.log.error(`MAIN (outer): ${this.err2Str(e)}`);\n        }\n    }\n\n    private async getRoborockUserHomedata(): Promise<void> {\n        try {\n            /********************************\n             * Initialize the login API (which is needed to get access to the real API).\n             ********************************/\n            this.log.debug(`${this.config.username}: Initializing the login API...`);\n            const loginApi = axios.create({\n                baseURL: 'https://euiot.roborock.com',\n                headers: {\n                    header_clientid: crypto.createHash('md5').update(this.config.username).update('should_be_unique').digest().toString('base64'),\n                },\n            });\n            // api/v1/getUrlByEmail(email = ...)\n\n            /*********************************\n             * Get userdata\n             *********************************/\n            this.log.debug(`${this.config.username}: Getting user data...`);\n            //let userdata = {} as { [k: string]: any };\n            let updateUserdata = false as true | false;\n            // Get existing data from ioBroker state 'userdata'\n            const userdataObj = await this.getStateAsync('userdata');\n            if (userdataObj && userdataObj.val && typeof userdataObj.val === 'string') {\n                this.userdata = JSON.parse(userdataObj.val);\n                if (!this.userdata.token || this.userdata.token.length < 10) {\n                    this.log.debug(`${this.config.username}: No token available, fetching new user data.`);\n                    updateUserdata = true;\n                }\n                if (!updateUserdata) {\n                    const lastChangeHours = Math.round((Date.now() - userdataObj.lc) / 1000 / 60 / 60); // Last state change, in hours\n                    if (lastChangeHours > 24 * 30) {\n                        this.log.debug(`${this.config.username}: Get new user data from cloud, since last update was more than 30 days ago`);\n                        updateUserdata = true;\n                    } else {\n                        this.log.debug(`${this.config.username}: Last user data update from Cloud: ${lastChangeHours} hours ago. Since less than 30 days: not updating.`);\n                    }\n                }\n            } else {\n                updateUserdata = true;\n            }\n            if (updateUserdata) {\n                this.log.debug(`${this.config.username}: Freshly getting user data from Roborock Cloud.`);\n                // Log in.\n                this.userdata = await loginApi\n                    .post(\n                        'api/v1/login',\n                        new URLSearchParams({\n                            username: this.config.username,\n                            password: this.config.password,\n                            needtwostepauth: 'false',\n                        }).toString(),\n                    )\n                    .then((res) => res.data.data);\n                await this.setStateAsync('userdata', { val: JSON.stringify(this.userdata), ack: true });\n                // Alternative without password:\n                // await loginApi.post('api/v1/sendEmailCode', new url.URLSearchParams({username: username, type: 'auth'}).toString()).then(res => res.data);\n                // // ... get code from user ...\n                // userdata = await loginApi.post('api/v1/loginWithCode', new url.URLSearchParams({username: username, verifycode: code, verifycodetype: 'AUTH_EMAIL_CODE'}).toString()).then(res => res.data.data);\n            }\n\n            /*********************************\n             * Get home details\n             *********************************/\n            this.log.debug(`${this.config.username}: Getting home details...`);\n            loginApi.defaults.headers.common['Authorization'] = this.userdata.token;\n            const rriot = this.userdata.rriot;\n            const homeId = await loginApi.get('api/v1/getHomeDetail').then((res) => res.data.data.rrHomeId);\n\n            // Initialize the real API.\n            this.log.debug(`${this.config.username}: Initializing the \"real\" Roborock API...`);\n            const api = axios.create({\n                baseURL: rriot.r.a,\n            });\n            api.interceptors.request.use((config) => {\n                const timestamp = Math.floor(Date.now() / 1000);\n                const nonce = crypto.randomBytes(6).toString('base64').substring(0, 6).replace('+', 'X').replace('/', 'Y');\n                const url = new URL(api.getUri(config));\n                const prestr = [rriot.u, rriot.s, nonce, timestamp, this.md5hex(url.pathname), /*queryparams*/ '', /*body*/ ''].join(':');\n                const mac = crypto.createHmac('sha256', rriot.h).update(prestr).digest('base64');\n                if (!config?.headers) throw `Expected 'config' and 'config.headers' not to be undefined`;\n                config.headers.Authorization = `Hawk id=\"${rriot.u}\", s=\"${rriot.s}\", ts=\"${timestamp}\", nonce=\"${nonce}\", mac=\"${mac}\"`;\n                return config;\n            });\n            this.homedata = await api.get(`user/homes/${homeId}`).then((res) => res.data.result);\n            if (!this.homedata || !this.homedata.id || !this.homedata.name || !this.homedata.products) throw `${this.config.username}: Could not receive valid home data!`;\n            for (const product of this.homedata.products) {\n                this.log.debug(`${this.homedata.name}: Received ${product.name} (model: ${product.model})`);\n            }\n            await this.setStateAsync('homedata', { val: JSON.stringify(this.homedata), ack: true });\n        } catch (e) {\n            this.log.error(this.err2Str(e));\n        }\n    }\n\n    /**\n     * convert MD5 to HEX\n     * @param str MD5\n     * @returns hex\n     */\n    private md5hex(str: string): string {\n        return crypto.createHash('md5').update(str).digest('hex');\n    }\n\n    /**\n     * convert MD5 to BIN\n     * @param str MD5\n     * @returns BIN buffer\n     */\n    private md5bin(str: string): Buffer {\n        return crypto.createHash('md5').update(str).digest();\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            // clearTimeout(timeout1);\n            // clearTimeout(timeout2);\n            // ...\n            // clearInterval(interval1);\n\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        if (state) {\n            // The state was changed\n            this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n        } else {\n            // The state was deleted\n            this.log.info(`state ${id} deleted`);\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new Roborock(options);\n} else {\n    // otherwise start the instance directly\n    (() => new Roborock())();\n}\n"],
  "mappings": "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",
  "names": ["crypto", "CRC32", "EventEmitter", "mqtt", "zlib", "deviceId", "axios"]
}
