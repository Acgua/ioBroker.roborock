{
  "version": 3,
  "sources": ["../../src/lib/methods.ts"],
  "sourcesContent": ["/**\n * Methods and Tools\n * @desc    Methods and Tools\n * @author  Acgua <https://github.com/Acgua/ioBroker.roborock>\n * @license Apache License 2.0\n *\n * ----------------------------------------------------------------------------------------\n * How to implement this file in main.ts (see also https://stackoverflow.com/a/58459668)\n * ----------------------------------------------------------------------------------------\n *  1. Add \"this: Roborock\" as first function parameter if you need access to \"this\"\n *       -> no need to provide this parameter when calling the method, though!\n *  1. Add line like \"import { err2Str, wait } from './lib/methods';\"\n *  2. Add keyword \"export\" before \"class Roborock extends utils.Adapter\"\n *  3. class Roborock: for each method, add line like: \"public wait = wait.bind(this);\"\n *           Note: use \"private wait...\" and not \"public\", if you do not need to access method from this file\n */\n\nimport { Roborock } from '../main';\n\n/**\n * Convert error to string\n * @param {*} error - any kind of thrown error\n * @returns string\n */\nexport function err2Str(error: any): string {\n    if (error instanceof Error) {\n        if (error.stack) return error.stack;\n        if (error.message) return error.message;\n        return JSON.stringify(error);\n    } else {\n        if (typeof error === 'string') return error;\n        return JSON.stringify(error);\n    }\n}\n\n/**\n * async wait/pause\n * Actually not needed since a single line, but for the sake of using wait more easily\n * @param {number} ms - number of milliseconds to wait\n */\nexport async function wait(this: Roborock, ms: number): Promise<void> {\n    try {\n        await new Promise((w) => setTimeout(w, ms));\n    } catch (e) {\n        this.log.error(this.err2Str(e));\n        return;\n    }\n}\n\n/**\n * Checks if an operand (variable, constant, object, ...) is considered as empty.\n * - empty:     undefined; null; string|array|object, stringified and only with white space(s), and/or `><[]{}`\n * - NOT empty: not matching anything above; any function; boolean false; number -1\n * inspired by helper.js from SmartControl adapter\n */\nexport function isEmpty(toCheck: any): true | false {\n    if (toCheck === null || typeof toCheck === 'undefined') return true;\n    if (typeof toCheck === 'function') return false;\n    let x = JSON.stringify(toCheck);\n    x = x.replace(/\\s+/g, ''); // white space(s)\n    x = x.replace(/\"+/g, ''); // \"\n    x = x.replace(/'+/g, ''); // '\n    x = x.replace(/\\[+/g, ''); // [\n    x = x.replace(/\\]+/g, ''); // ]\n    x = x.replace(/\\{+/g, ''); // {\n    x = x.replace(/\\}+/g, ''); // }\n    return x === '' ? true : false;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBO,SAAS,QAAQ,OAAoB;AACxC,MAAI,iBAAiB,OAAO;AACxB,QAAI,MAAM;AAAO,aAAO,MAAM;AAC9B,QAAI,MAAM;AAAS,aAAO,MAAM;AAChC,WAAO,KAAK,UAAU,KAAK;AAAA,EAC/B,OAAO;AACH,QAAI,OAAO,UAAU;AAAU,aAAO;AACtC,WAAO,KAAK,UAAU,KAAK;AAAA,EAC/B;AACJ;AAOA,eAAsB,KAAqB,IAA2B;AAClE,MAAI;AACA,UAAM,IAAI,QAAQ,CAAC,MAAM,WAAW,GAAG,EAAE,CAAC;AAAA,EAC9C,SAAS,GAAP;AACE,SAAK,IAAI,MAAM,KAAK,QAAQ,CAAC,CAAC;AAC9B;AAAA,EACJ;AACJ;AAQO,SAAS,QAAQ,SAA4B;AAChD,MAAI,YAAY,QAAQ,OAAO,YAAY;AAAa,WAAO;AAC/D,MAAI,OAAO,YAAY;AAAY,WAAO;AAC1C,MAAI,IAAI,KAAK,UAAU,OAAO;AAC9B,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,MAAI,EAAE,QAAQ,OAAO,EAAE;AACvB,MAAI,EAAE,QAAQ,OAAO,EAAE;AACvB,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,SAAO,MAAM,KAAK,OAAO;AAC7B;",
  "names": []
}
